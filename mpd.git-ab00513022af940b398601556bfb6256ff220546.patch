From: jat <jat@09075e82-0dd4-0310-85a5-a0d7c8717e4f>
Date: Fri, 1 Jun 2007 18:10:13 +0000 (+0000)
Subject: Tell the player process (and thus also the decode process) to quit when
X-Git-Url: http://git.infradead.org/?p=users%2Fdwmw2%2Fmpd.git;a=commitdiff_plain;h=ab00513022af940b398601556bfb6256ff220546

Tell the player process (and thus also the decode process) to quit when
playback is stopped completely.  This means the player process will no
longer have to wake up 100 times per second to see if it's been told to
start playing (the main process will just spawn a new player process when
it needs to).  On the downside, this means an extra pair of forks() and the
re-initializing of the player and decode processes each time playback is
restarted.


git-svn-id: https://svn.musicpd.org/mpd/trunk@6446 09075e82-0dd4-0310-85a5-a0d7c8717e4f
---

diff --git a/src/player.c b/src/player.c
index 4870dc7..e2dc210 100644
--- a/src/player.c
+++ b/src/player.c
@@ -155,6 +155,9 @@ int playerInit(void)
 			} else if (pc->cycleLogFiles) {
 				cycle_log_files();
 				pc->cycleLogFiles = 0;
+			} else if (pc->quit) {
+				pc->quit = 0;
+				break;
 			} else
 				my_usleep(10000);
 		}
@@ -174,6 +177,24 @@ int playerInit(void)
 	return 0;
 }
 
+int playerQuit(int fd)
+{
+	PlayerControl *pc = &(getPlayerData()->playerControl);
+
+	if (playerStop(fd) < 0)
+		return -1;
+
+	playerCloseAudio();
+
+	if (player_pid > 0) {
+		pc->quit = 1;
+		while (player_pid > 0 && pc->quit)
+			my_usleep(1000);
+	}
+
+	return 0;
+}
+
 int playerPlay(int fd, Song * song)
 {
 	PlayerControl *pc = &(getPlayerData()->playerControl);
@@ -341,6 +362,8 @@ void playerCloseAudio(void)
 		if (playerStop(STDERR_FILENO) < 0)
 			return;
 		pc->closeAudio = 1;
+		while (player_pid > 0 && pc->closeAudio)
+			my_usleep(1000);
 	}
 }
 
diff --git a/src/player.h b/src/player.h
index b62fab2..ce7eebc 100644
--- a/src/player.h
+++ b/src/player.h
@@ -57,6 +57,7 @@
 #define PLAYER_METADATA_STATE_WRITE     2
 
 typedef struct _PlayerControl {
+	volatile mpd_sint8 quit;
 	volatile mpd_sint8 stop;
 	volatile mpd_sint8 play;
 	volatile mpd_sint8 pause;
@@ -121,6 +122,8 @@ int getPlayerError(void);
 
 int playerInit(void);
 
+int playerQuit(int fd);
+
 int queueSong(Song * song);
 
 int getPlayerQueueState(void);
diff --git a/src/playerData.c b/src/playerData.c
index 30ff6d6..e4506c1 100644
--- a/src/playerData.c
+++ b/src/playerData.c
@@ -118,6 +118,7 @@ void initPlayerData(void)
 		      buffered_chunks * sizeof(mpd_sint8));
 	buffer->acceptMetadata = 0;
 
+	playerData_pd->playerControl.quit = 0;
 	playerData_pd->playerControl.stop = 0;
 	playerData_pd->playerControl.pause = 0;
 	playerData_pd->playerControl.play = 0;
diff --git a/src/playlist.c b/src/playlist.c
index de5a2a3..d68033e 100644
--- a/src/playlist.c
+++ b/src/playlist.c
@@ -786,7 +786,7 @@ int deleteFromPlaylist(int fd, int song)
 	    && playlist.current == songOrder) {
 		/*if(playlist.current>=playlist.length) return playerStop(fd);
 		   else return playPlaylistOrderNumber(fd,playlist.current); */
-		playerStop(STDERR_FILENO);
+		playerQuit(STDERR_FILENO);
 		playlist_noGoToNext = 1;
 	}
 
@@ -827,9 +827,8 @@ void deleteASongFromPlaylist(Song * song)
 int stopPlaylist(int fd)
 {
 	DEBUG("playlist: stop\n");
-	if (playerStop(fd) < 0)
+	if (playerQuit(fd) < 0)
 		return -1;
-	playerCloseAudio();
 	playlist.queued = -1;
 	playlist_state = PLAYLIST_STATE_STOP;
 	playlist_noGoToNext = 0;
